import "./chunk-5WWUZCGV.js";

// node_modules/hast-util-sanitize/lib/schema.js
var defaultSchema = {
  strip: ["script"],
  clobberPrefix: "user-content-",
  clobber: ["name", "id"],
  ancestors: {
    tbody: ["table"],
    tfoot: ["table"],
    thead: ["table"],
    td: ["table"],
    th: ["table"],
    tr: ["table"]
  },
  protocols: {
    href: ["http", "https", "mailto", "xmpp", "irc", "ircs"],
    cite: ["http", "https"],
    src: ["http", "https"],
    longDesc: ["http", "https"]
  },
  tagNames: [
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "br",
    "b",
    "i",
    "strong",
    "em",
    "a",
    "pre",
    "code",
    "img",
    "tt",
    "div",
    "ins",
    "del",
    "sup",
    "sub",
    "p",
    "ol",
    "ul",
    "table",
    "thead",
    "tbody",
    "tfoot",
    "blockquote",
    "dl",
    "dt",
    "dd",
    "kbd",
    "q",
    "samp",
    "var",
    "hr",
    "ruby",
    "rt",
    "rp",
    "li",
    "tr",
    "td",
    "th",
    "s",
    "strike",
    "summary",
    "details",
    "caption",
    "figure",
    "figcaption",
    "abbr",
    "bdo",
    "cite",
    "dfn",
    "mark",
    "small",
    "span",
    "time",
    "wbr",
    "input"
  ],
  attributes: {
    a: ["href"],
    img: ["src", "longDesc"],
    input: [
      ["type", "checkbox"],
      ["disabled", true]
    ],
    li: [["className", "task-list-item"]],
    div: ["itemScope", "itemType"],
    blockquote: ["cite"],
    del: ["cite"],
    ins: ["cite"],
    q: ["cite"],
    "*": [
      "abbr",
      "accept",
      "acceptCharset",
      "accessKey",
      "action",
      "align",
      "alt",
      "ariaDescribedBy",
      "ariaHidden",
      "ariaLabel",
      "ariaLabelledBy",
      "axis",
      "border",
      "cellPadding",
      "cellSpacing",
      "char",
      "charOff",
      "charSet",
      "checked",
      "clear",
      "cols",
      "colSpan",
      "color",
      "compact",
      "coords",
      "dateTime",
      "dir",
      "disabled",
      "encType",
      "htmlFor",
      "frame",
      "headers",
      "height",
      "hrefLang",
      "hSpace",
      "isMap",
      "id",
      "label",
      "lang",
      "maxLength",
      "media",
      "method",
      "multiple",
      "name",
      "noHref",
      "noShade",
      "noWrap",
      "open",
      "prompt",
      "readOnly",
      "rel",
      "rev",
      "rows",
      "rowSpan",
      "rules",
      "scope",
      "selected",
      "shape",
      "size",
      "span",
      "start",
      "summary",
      "tabIndex",
      "target",
      "title",
      "type",
      "useMap",
      "vAlign",
      "value",
      "vSpace",
      "width",
      "itemProp"
    ]
  },
  required: {
    input: {
      type: "checkbox",
      disabled: true
    }
  }
};

// node_modules/hast-util-sanitize/lib/index.js
var own = {}.hasOwnProperty;
var nodeSchema = {
  root: { children: all },
  doctype: handleDoctype,
  comment: handleComment,
  element: {
    tagName: handleTagName,
    properties: handleProperties,
    children: all
  },
  text: { value: handleValue },
  "*": { data: allow, position: allow }
};
function sanitize(node, schema) {
  let ctx = { type: "root", children: [] };
  if (node && typeof node === "object" && node.type) {
    const replace = one(
      Object.assign({}, defaultSchema, schema || {}),
      node,
      []
    );
    if (replace) {
      if (Array.isArray(replace)) {
        if (replace.length === 1) {
          ctx = replace[0];
        } else {
          ctx.children = replace;
        }
      } else {
        ctx = replace;
      }
    }
  }
  return ctx;
}
function one(schema, node, stack) {
  const type = node && node.type;
  const replacement = { type: node.type };
  let replace;
  if (own.call(nodeSchema, type)) {
    let definition = nodeSchema[type];
    if (typeof definition === "function") {
      definition = definition(schema, node);
    }
    if (definition) {
      const allowed = Object.assign({}, definition, nodeSchema["*"]);
      let key;
      replace = true;
      for (key in allowed) {
        if (own.call(allowed, key)) {
          const result = allowed[key](schema, node[key], node, stack);
          if (result === false) {
            replace = void 0;
            replacement[key] = node[key];
          } else if (result !== void 0 && result !== null) {
            replacement[key] = result;
          }
        }
      }
    }
  }
  if (replace) {
    return replacement;
  }
  return replacement.type === "element" && schema.strip && !schema.strip.includes(replacement.tagName) ? replacement.children : void 0;
}
function all(schema, children, node, stack) {
  const results = [];
  if (Array.isArray(children)) {
    let index = -1;
    if (node.type === "element") {
      stack.push(node.tagName);
    }
    while (++index < children.length) {
      const value = one(schema, children[index], stack);
      if (value) {
        if (Array.isArray(value)) {
          results.push(...value);
        } else {
          results.push(value);
        }
      }
    }
    if (node.type === "element") {
      stack.pop();
    }
  }
  return results;
}
function handleDoctype(schema) {
  return schema.allowDoctypes ? { name: handleDoctypeName } : void 0;
}
function handleComment(schema) {
  return schema.allowComments ? { value: handleCommentValue } : void 0;
}
function handleProperties(schema, properties, node, stack) {
  const name = handleTagName(schema, node.tagName, node, stack);
  const attrs = schema.attributes || {};
  const reqs = schema.required || {};
  const props = properties || {};
  const allowed = Object.assign(
    {},
    toPropertyValueMap(attrs["*"]),
    toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : [])
  );
  const result = {};
  let key;
  for (key in props) {
    if (own.call(props, key)) {
      let value = props[key];
      let definition;
      if (own.call(allowed, key)) {
        definition = allowed[key];
      } else if (data(key) && own.call(allowed, "data*")) {
        definition = allowed["data*"];
      } else {
        continue;
      }
      value = Array.isArray(value) ? handlePropertyValues(schema, value, key, definition) : handlePropertyValue(schema, value, key, definition);
      if (value !== void 0 && value !== null) {
        result[key] = value;
      }
    }
  }
  if (name && own.call(reqs, name)) {
    for (key in reqs[name]) {
      if (!own.call(result, key)) {
        result[key] = reqs[name][key];
      }
    }
  }
  return result;
}
function handleDoctypeName() {
  return "html";
}
function handleTagName(schema, tagName, _, stack) {
  const name = typeof tagName === "string" ? tagName : "";
  let index = -1;
  if (!name || name === "*" || schema.tagNames && !schema.tagNames.includes(name)) {
    return false;
  }
  if (schema.ancestors && own.call(schema.ancestors, name)) {
    while (++index < schema.ancestors[name].length) {
      if (stack.includes(schema.ancestors[name][index])) {
        return name;
      }
    }
    return false;
  }
  return name;
}
function handleCommentValue(_, value) {
  const result = typeof value === "string" ? value : "";
  const index = result.indexOf("-->");
  return index < 0 ? result : result.slice(0, index);
}
function handleValue(_, value) {
  return typeof value === "string" ? value : "";
}
function allow(_, value) {
  return value;
}
function handlePropertyValues(schema, values, prop, definition) {
  let index = -1;
  const result = [];
  while (++index < values.length) {
    const value = handlePropertyValue(schema, values[index], prop, definition);
    if (value !== void 0 && value !== null) {
      result.push(value);
    }
  }
  return result;
}
function handlePropertyValue(schema, value, prop, definition) {
  if ((typeof value === "boolean" || typeof value === "number" || typeof value === "string") && safeProtocol(schema, value, prop) && (definition.length === 0 || definition.some(
    (allowed) => allowed && typeof allowed === "object" && "flags" in allowed ? allowed.test(String(value)) : allowed === value
  ))) {
    return schema.clobberPrefix && schema.clobber && schema.clobber.includes(prop) ? schema.clobberPrefix + value : value;
  }
}
function safeProtocol(schema, value, prop) {
  const url = String(value);
  const colon = url.indexOf(":");
  const questionMark = url.indexOf("?");
  const numberSign = url.indexOf("#");
  const slash = url.indexOf("/");
  const protocols = schema.protocols && own.call(schema.protocols, prop) ? schema.protocols[prop].concat() : [];
  let index = -1;
  if (protocols.length === 0 || colon < 0 || // If the first colon is after a `?`, `#`, or `/`, itâ€™s not a protocol.
  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {
    return true;
  }
  while (++index < protocols.length) {
    if (colon === protocols[index].length && url.slice(0, protocols[index].length) === protocols[index]) {
      return true;
    }
  }
  return false;
}
function toPropertyValueMap(values) {
  const result = {};
  let index = -1;
  while (++index < values.length) {
    const value = values[index];
    if (Array.isArray(value)) {
      result[value[0]] = value.slice(1);
    } else {
      result[value] = [];
    }
  }
  return result;
}
function data(prop) {
  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === "data";
}

// node_modules/rehype-sanitize/index.js
function rehypeSanitize(options = defaultSchema) {
  return (tree) => sanitize(tree, options);
}
export {
  rehypeSanitize as default,
  defaultSchema
};
//# sourceMappingURL=rehype-sanitize.js.map
