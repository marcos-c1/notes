{
  "version": 3,
  "sources": ["../../hast-util-sanitize/lib/schema.js", "../../hast-util-sanitize/lib/index.js", "../../rehype-sanitize/index.js"],
  "sourcesContent": ["/** @type {import('./index.js').Schema} */\nexport const defaultSchema = {\n  strip: ['script'],\n  clobberPrefix: 'user-content-',\n  clobber: ['name', 'id'],\n  ancestors: {\n    tbody: ['table'],\n    tfoot: ['table'],\n    thead: ['table'],\n    td: ['table'],\n    th: ['table'],\n    tr: ['table']\n  },\n  protocols: {\n    href: ['http', 'https', 'mailto', 'xmpp', 'irc', 'ircs'],\n    cite: ['http', 'https'],\n    src: ['http', 'https'],\n    longDesc: ['http', 'https']\n  },\n  tagNames: [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'br',\n    'b',\n    'i',\n    'strong',\n    'em',\n    'a',\n    'pre',\n    'code',\n    'img',\n    'tt',\n    'div',\n    'ins',\n    'del',\n    'sup',\n    'sub',\n    'p',\n    'ol',\n    'ul',\n    'table',\n    'thead',\n    'tbody',\n    'tfoot',\n    'blockquote',\n    'dl',\n    'dt',\n    'dd',\n    'kbd',\n    'q',\n    'samp',\n    'var',\n    'hr',\n    'ruby',\n    'rt',\n    'rp',\n    'li',\n    'tr',\n    'td',\n    'th',\n    's',\n    'strike',\n    'summary',\n    'details',\n    'caption',\n    'figure',\n    'figcaption',\n    'abbr',\n    'bdo',\n    'cite',\n    'dfn',\n    'mark',\n    'small',\n    'span',\n    'time',\n    'wbr',\n    'input'\n  ],\n  attributes: {\n    a: ['href'],\n    img: ['src', 'longDesc'],\n    input: [\n      ['type', 'checkbox'],\n      ['disabled', true]\n    ],\n    li: [['className', 'task-list-item']],\n    div: ['itemScope', 'itemType'],\n    blockquote: ['cite'],\n    del: ['cite'],\n    ins: ['cite'],\n    q: ['cite'],\n    '*': [\n      'abbr',\n      'accept',\n      'acceptCharset',\n      'accessKey',\n      'action',\n      'align',\n      'alt',\n      'ariaDescribedBy',\n      'ariaHidden',\n      'ariaLabel',\n      'ariaLabelledBy',\n      'axis',\n      'border',\n      'cellPadding',\n      'cellSpacing',\n      'char',\n      'charOff',\n      'charSet',\n      'checked',\n      'clear',\n      'cols',\n      'colSpan',\n      'color',\n      'compact',\n      'coords',\n      'dateTime',\n      'dir',\n      'disabled',\n      'encType',\n      'htmlFor',\n      'frame',\n      'headers',\n      'height',\n      'hrefLang',\n      'hSpace',\n      'isMap',\n      'id',\n      'label',\n      'lang',\n      'maxLength',\n      'media',\n      'method',\n      'multiple',\n      'name',\n      'noHref',\n      'noShade',\n      'noWrap',\n      'open',\n      'prompt',\n      'readOnly',\n      'rel',\n      'rev',\n      'rows',\n      'rowSpan',\n      'rules',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'span',\n      'start',\n      'summary',\n      'tabIndex',\n      'target',\n      'title',\n      'type',\n      'useMap',\n      'vAlign',\n      'value',\n      'vSpace',\n      'width',\n      'itemProp'\n    ]\n  },\n  required: {\n    input: {\n      type: 'checkbox',\n      disabled: true\n    }\n  }\n}\n", "/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Content} Content\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {Content | Root} Node\n *\n * @typedef {Properties[string]} PropertyValue\n *   Possible property values.\n * @typedef {string | number | boolean} PrimitivePropertyValue\n *   Possible primitive HTML attribute values.\n *\n * @typedef {Record<string, Array<string | [string, ...Array<PrimitivePropertyValue | RegExp>]>>} Attributes\n *  Map of tag names to allow lists for each property.\n * @typedef {Record<string, Array<PrimitivePropertyValue | RegExp>>} AttributeClean\n *   Normalized input.\n *\n * @typedef Schema\n *   Sanitization configuration.\n * @property {Attributes | undefined} [attributes]\n *   Map of tag names to allowed properties.\n *\n *   The special `'*'` key defines property names allowed on all elements.\n * @property {Record<string, Record<string, PropertyValue>> | undefined} [required]\n *   Map of tag names to required property names and their default property value.\n * @property {Array<string> | undefined} [tagNames]\n *   List of allowed tag names.\n * @property {Record<string, Array<string>> | undefined} [protocols]\n *   Map of protocols to allow in property values.\n * @property {Record<string, Array<string>> | undefined} [ancestors]\n *   Map of tag names to their required ancestor elements.\n * @property {Array<string> | undefined} [clobber]\n *   List of allowed property names which can clobber.\n * @property {string | undefined} [clobberPrefix]\n *   Prefix to use before potentially clobbering property names.\n * @property {Array<string> | undefined} [strip]\n *   Names of elements to strip from the tree.\n * @property {boolean | undefined} [allowComments]\n *   Whether to allow comments.\n * @property {boolean | undefined} [allowDoctypes]\n *   Whether to allow doctypes.\n *\n * @typedef {(schema: Schema, value: any, node: any, stack: Array<string>) => unknown} Handler\n * @typedef {Record<string, Handler>} NodeDefinition\n * @typedef {((schema: Schema, node: Node) => NodeDefinition | undefined)} NodeDefinitionGetter\n * @typedef {Record<string, NodeDefinition | NodeDefinitionGetter>} NodeSchema\n */\n\nimport {defaultSchema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {NodeSchema} */\nconst nodeSchema = {\n  root: {children: all},\n  doctype: handleDoctype,\n  comment: handleComment,\n  element: {\n    tagName: handleTagName,\n    properties: handleProperties,\n    children: all\n  },\n  text: {value: handleValue},\n  '*': {data: allow, position: allow}\n}\n\n/**\n * Utility to sanitize a tree\n *\n * @param {Node} node\n *   Hast tree to sanitize\n * @param {Schema} [schema]\n *   Schema defining how to sanitize - defaults to Github style sanitation\n */\nexport function sanitize(node, schema) {\n  /** @type {Node} */\n  let ctx = {type: 'root', children: []}\n\n  if (node && typeof node === 'object' && node.type) {\n    const replace = one(\n      Object.assign({}, defaultSchema, schema || {}),\n      node,\n      []\n    )\n\n    if (replace) {\n      if (Array.isArray(replace)) {\n        if (replace.length === 1) {\n          ctx = replace[0]\n        } else {\n          // @ts-expect-error Assume `root` is not a child.\n          ctx.children = replace\n        }\n      } else {\n        ctx = replace\n      }\n    }\n  }\n\n  return ctx\n}\n\n/**\n * Sanitize `node`.\n *\n * @param {Schema} schema\n * @param {Node} node\n * @param {Array<string>} stack\n * @returns {Node | Array<Node> | undefined}\n */\nfunction one(schema, node, stack) {\n  const type = node && node.type\n  /** @type {Node} */\n  // @ts-expect-error rest of props added later.\n  const replacement = {type: node.type}\n  /** @type {boolean | undefined} */\n  let replace\n\n  if (own.call(nodeSchema, type)) {\n    /** @type {NodeDefinition | NodeDefinitionGetter | undefined} */\n    let definition = nodeSchema[type]\n\n    if (typeof definition === 'function') {\n      definition = definition(schema, node)\n    }\n\n    if (definition) {\n      const allowed = Object.assign({}, definition, nodeSchema['*'])\n      /** @type {string} */\n      let key\n\n      replace = true\n\n      for (key in allowed) {\n        if (own.call(allowed, key)) {\n          // @ts-expect-error: fine.\n          // type-coverage:ignore-next-line\n          const result = allowed[key](schema, node[key], node, stack)\n\n          // eslint-disable-next-line max-depth\n          if (result === false) {\n            replace = undefined\n            // Set the non-safe value.\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = node[key]\n          } else if (result !== undefined && result !== null) {\n            // @ts-expect-error: fine.\n            // type-coverage:ignore-next-line\n            replacement[key] = result\n          }\n        }\n      }\n    }\n  }\n\n  if (replace) {\n    return replacement\n  }\n\n  return replacement.type === 'element' &&\n    schema.strip &&\n    !schema.strip.includes(replacement.tagName)\n    ? replacement.children\n    : undefined\n}\n\n/**\n * Sanitize `children`.\n *\n * @type {Handler}\n * @param {Array<Node>} children\n * @param {Node} node\n * @returns {Array<Node>}\n */\nfunction all(schema, children, node, stack) {\n  /** @type {Array<Node>} */\n  const results = []\n\n  if (Array.isArray(children)) {\n    let index = -1\n\n    if (node.type === 'element') {\n      stack.push(node.tagName)\n    }\n\n    while (++index < children.length) {\n      const value = one(schema, children[index], stack)\n\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value)\n        } else {\n          results.push(value)\n        }\n      }\n    }\n\n    if (node.type === 'element') {\n      stack.pop()\n    }\n  }\n\n  return results\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleDoctype(schema) {\n  return schema.allowDoctypes ? {name: handleDoctypeName} : undefined\n}\n\n/** @type {NodeDefinitionGetter} */\nfunction handleComment(schema) {\n  return schema.allowComments ? {value: handleCommentValue} : undefined\n}\n\n/**\n * Sanitize `properties`.\n *\n * @type {Handler}\n * @param {Properties} properties\n * @param {Element} node\n * @returns {Properties}\n */\nfunction handleProperties(schema, properties, node, stack) {\n  const name = handleTagName(schema, node.tagName, node, stack)\n  /* c8 ignore next */\n  const attrs = schema.attributes || {}\n  /* c8 ignore next */\n  const reqs = schema.required || {}\n  const props = properties || {}\n  const allowed = Object.assign(\n    {},\n    toPropertyValueMap(attrs['*']),\n    toPropertyValueMap(name && own.call(attrs, name) ? attrs[name] : [])\n  )\n  /** @type {Properties} */\n  const result = {}\n  /** @type {string} */\n  let key\n\n  for (key in props) {\n    if (own.call(props, key)) {\n      let value = props[key]\n      /** @type {AttributeClean[string]} */\n      let definition\n\n      if (own.call(allowed, key)) {\n        definition = allowed[key]\n      } else if (data(key) && own.call(allowed, 'data*')) {\n        definition = allowed['data*']\n      } else {\n        continue\n      }\n\n      value = Array.isArray(value)\n        ? handlePropertyValues(schema, value, key, definition)\n        : handlePropertyValue(schema, value, key, definition)\n\n      if (value !== undefined && value !== null) {\n        result[key] = value\n      }\n    }\n  }\n\n  if (name && own.call(reqs, name)) {\n    for (key in reqs[name]) {\n      if (!own.call(result, key)) {\n        result[key] = reqs[name][key]\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * Always return a valid HTML5 doctype.\n *\n * @type {Handler}\n * @returns {string}\n */\nfunction handleDoctypeName() {\n  return 'html'\n}\n\n/**\n * Sanitize `tagName`.\n *\n * @param {Schema} schema\n * @param {string} tagName\n * @param {Node} _\n * @param {Array<string>} stack\n * @returns {string | false}\n */\nfunction handleTagName(schema, tagName, _, stack) {\n  const name = typeof tagName === 'string' ? tagName : ''\n  let index = -1\n\n  if (\n    !name ||\n    name === '*' ||\n    (schema.tagNames && !schema.tagNames.includes(name))\n  ) {\n    return false\n  }\n\n  // Some nodes can break out of their context if they don’t have a certain\n  // ancestor.\n  if (schema.ancestors && own.call(schema.ancestors, name)) {\n    while (++index < schema.ancestors[name].length) {\n      if (stack.includes(schema.ancestors[name][index])) {\n        return name\n      }\n    }\n\n    return false\n  }\n\n  return name\n}\n\n/**\n * See <https://html.spec.whatwg.org/multipage/parsing.html#serialising-html-fragments>\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleCommentValue(_, value) {\n  /** @type {string} */\n  const result = typeof value === 'string' ? value : ''\n  const index = result.indexOf('-->')\n  return index < 0 ? result : result.slice(0, index)\n}\n\n/**\n * Sanitize `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n * @returns {string}\n */\nfunction handleValue(_, value) {\n  return typeof value === 'string' ? value : ''\n}\n\n/**\n * Allow `value`.\n *\n * @type {Handler}\n * @param {unknown} value\n */\nfunction allow(_, value) {\n  return value\n}\n\n/**\n * Sanitize a property value which is a list.\n *\n * @param {Schema} schema\n * @param {Array<unknown>} values\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {Array<string | number>}\n */\nfunction handlePropertyValues(schema, values, prop, definition) {\n  let index = -1\n  /** @type {Array<string | number>} */\n  const result = []\n\n  while (++index < values.length) {\n    const value = handlePropertyValue(schema, values[index], prop, definition)\n\n    if (value !== undefined && value !== null) {\n      // @ts-expect-error Assume no booleans were in arrays.\n      result.push(value)\n    }\n  }\n\n  return result\n}\n\n/**\n * Sanitize a property value.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @param {AttributeClean[string]} definition\n * @returns {PropertyValue}\n */\nfunction handlePropertyValue(schema, value, prop, definition) {\n  if (\n    (typeof value === 'boolean' ||\n      typeof value === 'number' ||\n      typeof value === 'string') &&\n    safeProtocol(schema, value, prop) &&\n    (definition.length === 0 ||\n      definition.some((allowed) =>\n        allowed && typeof allowed === 'object' && 'flags' in allowed\n          ? allowed.test(String(value))\n          : allowed === value\n      ))\n  ) {\n    return schema.clobberPrefix &&\n      schema.clobber &&\n      schema.clobber.includes(prop)\n      ? schema.clobberPrefix + value\n      : value\n  }\n}\n\n/**\n * Check whether `value` is a safe URL.\n *\n * @param {Schema} schema\n * @param {unknown} value\n * @param {string} prop\n * @returns {boolean}\n */\nfunction safeProtocol(schema, value, prop) {\n  const url = String(value)\n  const colon = url.indexOf(':')\n  const questionMark = url.indexOf('?')\n  const numberSign = url.indexOf('#')\n  const slash = url.indexOf('/')\n  const protocols =\n    schema.protocols && own.call(schema.protocols, prop)\n      ? schema.protocols[prop].concat()\n      : []\n  let index = -1\n\n  if (\n    protocols.length === 0 ||\n    colon < 0 ||\n    // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n    (slash > -1 && colon > slash) ||\n    (questionMark > -1 && colon > questionMark) ||\n    (numberSign > -1 && colon > numberSign)\n  ) {\n    return true\n  }\n\n  while (++index < protocols.length) {\n    if (\n      colon === protocols[index].length &&\n      url.slice(0, protocols[index].length) === protocols[index]\n    ) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a map from a list of props or a list of properties and values.\n *\n * @param {Attributes[string]} values\n * @returns {AttributeClean}\n */\nfunction toPropertyValueMap(values) {\n  /** @type {AttributeClean} */\n  const result = {}\n  let index = -1\n\n  while (++index < values.length) {\n    const value = values[index]\n\n    if (Array.isArray(value)) {\n      result[value[0]] = value.slice(1)\n    } else {\n      result[value] = []\n    }\n  }\n\n  return result\n}\n\n/**\n * Check if `prop` is a data property.\n *\n * @param {string} prop\n * @returns {boolean}\n */\nfunction data(prop) {\n  return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data'\n}\n", "/**\n * @typedef {import('hast').Root} Root\n *\n * @typedef {import('hast-util-sanitize').Schema} Options\n *   The sanitation schema defines how and if nodes and properties should be cleaned.\n *   See `hast-util-sanitize`.\n *   The default schema is exported as `defaultSchema`.\n */\n\nimport {sanitize as hastUtilSanitize, defaultSchema} from 'hast-util-sanitize'\n\n/**\n * Plugin to sanitize HTML.\n *\n * @type {import('unified').Plugin<[Options?] | Array<void>, Root, Root>}\n */\nexport default function rehypeSanitize(options = defaultSchema) {\n  // @ts-expect-error: assume input `root` matches output root.\n  return (tree) => hastUtilSanitize(tree, options)\n}\n\nexport {defaultSchema} from 'hast-util-sanitize'\n"],
  "mappings": "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",
  "names": []
}
